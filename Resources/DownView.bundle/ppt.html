<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="initial-scale=1.0" />
    <link rel="stylesheet" href="ppt/dist/reveal.css" />
    DOWN_THEME
    <link rel="stylesheet" href="themes/mermaid.css" />
    <script src="js/markmap.min.js"></script>
    <script src="js/index.js"></script>
    <title></title>
    <style>

      @font-face {
          font-family: 'TsangerJinKai02-W04';
          font-display: fallback;
          src: url('DOWN_FONT_PATH/TsangerJinKai02-W04.ttf') format('truetype');
      }

      DOWN_CSS

      .reveal .slide-number {
        left: 24px;
        right: auto;
        bottom: 24px;
        font-size: 1.3rem;
        background: rgba(0, 0, 0, 0.08);
        color: #000;
        padding: 4px 12px;
        border-radius: 999px;
        backdrop-filter: blur(12px);
      }

      .reveal .slide-number span {
        font-size: inherit;
      }
    </style>
  </head>

  <body>
    <div class="reveal" id="write">
      <div class="slides">
        <section data-markdown>
          <script type="text/template">
            DOWN_RAW
          </script>
        </section>
      </div>
    </div>

    <script>
      // Setup text selection using common module
      MiaoYanCommon.setupTextSelection();
    </script>

    <script>
      // Setup checkboxes using common module
      MiaoYanCommon.setupCheckboxes();
    </script>
    <script src="ppt/dist/reveal.js"></script>
    <script src="ppt/plugin/markdown/markdown.js"></script>
    <script src="ppt/plugin/highlight/highlight.js"></script>
    <script src="ppt/plugin/notes/notes.js"></script>
    <script src="ppt/plugin/zoom/zoom.js"></script>
    <script src="ppt/plugin/math/math.js"></script>

    <script>
      if ('DOWN_EXPORT_TYPE' === 'ppt') {
        if (window.location.search.indexOf('print-pdf') === -1) {
          window.location.search = 'print-pdf';
        }

        document.getElementById('write').style.visibility = 'hidden';

        window.addEventListener('load', function () {
          const iframeEle = document.querySelector(
            '.pdf-page .slide-background-content iframe',
          );
          const iframeBg = document.querySelector(
            '.pdf-page section[data-background-iframe]',
          );
          const pdfSections = document.getElementsByClassName('pdf-page');
          pdfSections.forEach((item) => {
            if (item.contains(iframeEle)) {
              item.hidden = true;
            }
            if (item.contains(iframeBg)) {
              item.hidden = true;
            }
          });
          document.getElementById('write').style.visibility = 'visible';
        });
      }

      function loadInlineRevealOptions() {
        const templateNode = document.querySelector(
          'section[data-markdown] script[type="text/template"]',
        );

        if (!templateNode) {
          return {};
        }

        const rawMarkdown = templateNode.textContent;
        const leadingWhitespaceMatch = rawMarkdown.match(/^\s*/);
        const leadingWhitespace = leadingWhitespaceMatch ? leadingWhitespaceMatch[0] : '';
        const firstNonWhitespaceIndex = leadingWhitespace.length;

        if (!rawMarkdown.startsWith('<!--', firstNonWhitespaceIndex)) {
          return {};
        }

        const commentStart = rawMarkdown.indexOf('<!--', firstNonWhitespaceIndex);
        const commentEnd = rawMarkdown.indexOf('-->', commentStart + 4);

        if (commentEnd === -1) {
          return {};
        }

        const headComment = rawMarkdown.slice(commentStart + 4, commentEnd);
        const inlineConfig = {};
        const lines = headComment
          .split('\n')
          .map((line) => line.trim())
          .filter(Boolean)
          .filter((line) => line.includes(':'));

        function assignNestedOption(path, value) {
          const segments = path.split('.');
          let current = inlineConfig;

          segments.forEach((segment, index) => {
            if (index === segments.length - 1) {
              current[segment] = value;
              return;
            }

            if (!current[segment] || typeof current[segment] !== 'object') {
              current[segment] = {};
            }

            current = current[segment];
          });
        }

        lines.forEach((line) => {
          const colonIndex = line.indexOf(':');
          const key = line.slice(0, colonIndex).trim();
          let value = line.slice(colonIndex + 1).trim();

          if (!key) {
            return;
          }

          if (value.startsWith('[') && value.endsWith(']')) {
            const listBody = value.slice(1, -1);
            assignNestedOption(
              key,
              listBody
                .split(',')
                .map((item) => item.trim())
                .filter((item) => item.length > 0),
            );
            return;
          }

          if (
            (value.startsWith('"') && value.endsWith('"')) ||
            (value.startsWith("'") && value.endsWith("'"))
          ) {
            value = value.slice(1, -1);
          }

          if (/^null$/i.test(value)) {
            assignNestedOption(key, null);
            return;
          }

          if (/^undefined$/i.test(value)) {
            assignNestedOption(key, undefined);
            return;
          }

          if (/^(true|false)$/i.test(value)) {
            assignNestedOption(key, /^true$/i.test(value));
            return;
          }

          const numericValue = Number(value);

          if (!Number.isNaN(numericValue)) {
            assignNestedOption(key, numericValue);
            return;
          }

          assignNestedOption(key, value);
        });

        const withoutComment =
          rawMarkdown.slice(0, commentStart) + rawMarkdown.slice(commentEnd + 3);
        templateNode.textContent = withoutComment.trimStart();

        return inlineConfig;
      }

      function deepMerge(target, source) {
        Object.keys(source).forEach((key) => {
          const srcValue = source[key];

          if (Array.isArray(srcValue)) {
            target[key] = srcValue.slice();
            return;
          }

          if (srcValue && typeof srcValue === 'object') {
            if (
              !target[key] ||
              typeof target[key] !== 'object' ||
              Array.isArray(target[key])
            ) {
              target[key] = {};
            }
            deepMerge(target[key], srcValue);
            return;
          }

          target[key] = srcValue;
        });
        return target;
      }

      const defaultRevealOptions = {
        width: '100%',
        height: '100%',
        controls: true,
        progress: true,
        history: true,
        transition: 'slide',
        backgroundTransition: 'none',
        center: false,
        pdfSeparateFragments: false,
        highlight: {
          highlightOnLoad: true,
          lineNumbers: true,
        },
        slideNumber: false,
        showSlideNumber: 'all',
        hash: true,
        plugins: [
          RevealMarkdown,
          RevealHighlight,
          RevealNotes,
          // Disable zoom in PPT mode to avoid layout issues
          // RevealZoom,
          RevealMath.KaTeX,
        ],
      };

      const inlineRevealOptions = loadInlineRevealOptions();
      const mergedRevealOptions = deepMerge(
        deepMerge({}, defaultRevealOptions),
        inlineRevealOptions,
      );

      Reveal.initialize(mergedRevealOptions);

      document.addEventListener('DOMContentLoaded', function () {
        const sections = document.getElementsByTagName('section');
        if (sections.length < 1) {
          return;
        }
        sections.forEach((item) => {
          if (item.childElementCount === 1) {
            item.classList.add('section-center');
            item.classList.add('center');
          } else {
            const option = item.clientHeight / document.body.offsetHeight;
            if (option > 0.75) {
              item.classList.add('section-option');
            }
          }
        });
      });
    </script>
    <script>
      document.addEventListener('DOMContentLoaded', function () {
        // Optimize images using common module
        MiaoYanCommon.optimizeImages();

        // Initialize Markmap for PPT mode using diagram handler
        DiagramHandler.initializeMarkmapForPPT();
      });
    </script>
    <script>
      function postBackgroundColor(currentSlide) {
        let color = '';
        if (
          currentSlide &&
          currentSlide.dataset &&
          currentSlide.dataset.background
        ) {
          color = currentSlide.dataset.background;
        }
        window.webkit &&
          window.webkit.messageHandlers.revealBackgroundColor.postMessage(
            color,
          );
      }

      document.addEventListener('DOMContentLoaded', function () {
        Reveal.on('ready', (event) => {
          postBackgroundColor(event.currentSlide);
        });
        Reveal.on('slidechanged', (event) => {
          postBackgroundColor(event.currentSlide);
        });
      });
    </script>
  </body>
</html>
