<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="initial-scale=1.0" />
    <link rel="stylesheet" href="ppt/dist/reveal.css" />
    DOWN_THEME
    <script src="js/markmap.min.js"></script>
    <title></title>
    <style>

      @font-face {
          font-family: 'TsangerJinKai02-W04';
          font-display: fallback;
          src: url('DOWN_FONT_PATH/TsangerJinKai02-W04.ttf') format('truetype');
      }

      DOWN_CSS

      .reveal .slide-number {
        left: 24px;
        right: auto;
        bottom: 24px;
        font-size: 1.3rem;
        background: rgba(0, 0, 0, 0.08);
        color: #000;
        padding: 4px 12px;
        border-radius: 999px;
        backdrop-filter: blur(12px);
      }

      .reveal .slide-number span {
        font-size: inherit;
      }
    </style>
  </head>

  <body>
    <div class="reveal" id="write">
      <div class="slides">
        <section data-markdown>
          <script type="text/template">
            DOWN_RAW
          </script>
        </section>
      </div>
    </div>

    <script>
      function getSelectionAndSendMessage() {
        const txt = document.getSelection().toString();
        window.webkit.messageHandlers.newSelectionDetected.postMessage(txt);
      }

      document.onmouseup = getSelectionAndSendMessage;
      document.onkeyup = getSelectionAndSendMessage;
      document.oncontextmenu = getSelectionAndSendMessage;
    </script>

    <script>
      let preList = document.getElementsByTagName('input'),
        length = preList.length,
        i = 0;

      for (i; i < length; i++) {
        preList[i].disabled = true;

        if (
          preList[i].parentNode.tagName === 'P' &&
          preList[i].parentNode.parentNode.tagName === 'LI'
        ) {
          preList[i].parentNode.parentNode.parentNode.classList.add('cb');
          continue;
        }

        if (preList[i].parentNode.tagName !== 'LI') {
          continue;
        }

        preList[i].parentNode.parentNode.classList.add('cb');
      }
    </script>
    <script src="ppt/dist/reveal.js"></script>
    <script src="ppt/plugin/markdown/markdown.js"></script>
    <script src="ppt/plugin/highlight/highlight.js"></script>
    <script src="ppt/plugin/notes/notes.js"></script>
    <script src="ppt/plugin/zoom/zoom.js"></script>
    <script src="ppt/plugin/math/math.js"></script>

    <script>
      if ('DOWN_EXPORT_TYPE' === 'ppt') {
        if (window.location.search.indexOf('print-pdf') === -1) {
          window.location.search = 'print-pdf';
        }

        document.getElementById('write').style.visibility = 'hidden';

        window.addEventListener('load', function () {
          const iframeEle = document.querySelector(
            '.pdf-page .slide-background-content iframe',
          );
          const iframeBg = document.querySelector(
            '.pdf-page section[data-background-iframe]',
          );
          const pdfSections = document.getElementsByClassName('pdf-page');
          pdfSections.forEach((item) => {
            if (item.contains(iframeEle)) {
              item.hidden = true;
            }
            if (item.contains(iframeBg)) {
              item.hidden = true;
            }
          });
          document.getElementById('write').style.visibility = 'visible';
        });
      }

      function loadInlineRevealOptions() {
        const templateNode = document.querySelector(
          'section[data-markdown] script[type="text/template"]',
        );

        if (!templateNode) {
          return {};
        }

        const rawMarkdown = templateNode.textContent;
        const leadingWhitespaceMatch = rawMarkdown.match(/^\s*/);
        const leadingWhitespace = leadingWhitespaceMatch ? leadingWhitespaceMatch[0] : '';
        const firstNonWhitespaceIndex = leadingWhitespace.length;

        if (!rawMarkdown.startsWith('<!--', firstNonWhitespaceIndex)) {
          return {};
        }

        const commentStart = rawMarkdown.indexOf('<!--', firstNonWhitespaceIndex);
        const commentEnd = rawMarkdown.indexOf('-->', commentStart + 4);

        if (commentEnd === -1) {
          return {};
        }

        const headComment = rawMarkdown.slice(commentStart + 4, commentEnd);
        const inlineConfig = {};
        const lines = headComment
          .split('\n')
          .map((line) => line.trim())
          .filter(Boolean)
          .filter((line) => line.includes(':'));

        function assignNestedOption(path, value) {
          const segments = path.split('.');
          let current = inlineConfig;

          segments.forEach((segment, index) => {
            if (index === segments.length - 1) {
              current[segment] = value;
              return;
            }

            if (!current[segment] || typeof current[segment] !== 'object') {
              current[segment] = {};
            }

            current = current[segment];
          });
        }

        lines.forEach((line) => {
          const colonIndex = line.indexOf(':');
          const key = line.slice(0, colonIndex).trim();
          let value = line.slice(colonIndex + 1).trim();

          if (!key) {
            return;
          }

          if (value.startsWith('[') && value.endsWith(']')) {
            const listBody = value.slice(1, -1);
            assignNestedOption(
              key,
              listBody
                .split(',')
                .map((item) => item.trim())
                .filter((item) => item.length > 0),
            );
            return;
          }

          if (
            (value.startsWith('"') && value.endsWith('"')) ||
            (value.startsWith("'") && value.endsWith("'"))
          ) {
            value = value.slice(1, -1);
          }

          if (/^null$/i.test(value)) {
            assignNestedOption(key, null);
            return;
          }

          if (/^undefined$/i.test(value)) {
            assignNestedOption(key, undefined);
            return;
          }

          if (/^(true|false)$/i.test(value)) {
            assignNestedOption(key, /^true$/i.test(value));
            return;
          }

          const numericValue = Number(value);

          if (!Number.isNaN(numericValue)) {
            assignNestedOption(key, numericValue);
            return;
          }

          assignNestedOption(key, value);
        });

        const withoutComment =
          rawMarkdown.slice(0, commentStart) + rawMarkdown.slice(commentEnd + 3);
        templateNode.textContent = withoutComment.trimStart();

        return inlineConfig;
      }

      function deepMerge(target, source) {
        Object.keys(source).forEach((key) => {
          const srcValue = source[key];

          if (Array.isArray(srcValue)) {
            target[key] = srcValue.slice();
            return;
          }

          if (srcValue && typeof srcValue === 'object') {
            if (
              !target[key] ||
              typeof target[key] !== 'object' ||
              Array.isArray(target[key])
            ) {
              target[key] = {};
            }
            deepMerge(target[key], srcValue);
            return;
          }

          target[key] = srcValue;
        });
        return target;
      }

      const defaultRevealOptions = {
        width: '100%',
        height: '100%',
        controls: true,
        progress: true,
        history: true,
        transition: 'slide',
        backgroundTransition: 'none',
        center: false,
        pdfSeparateFragments: false,
        highlight: {
          highlightOnLoad: true,
          lineNumbers: true,
        },
        slideNumber: false,
        showSlideNumber: 'all',
        hash: true,
        plugins: [
          RevealMarkdown,
          RevealHighlight,
          RevealNotes,
          // Disable zoom in PPT mode to avoid layout issues
          // RevealZoom,
          RevealMath.KaTeX,
        ],
      };

      const inlineRevealOptions = loadInlineRevealOptions();
      const mergedRevealOptions = deepMerge(
        deepMerge({}, defaultRevealOptions),
        inlineRevealOptions,
      );

      Reveal.initialize(mergedRevealOptions);

      document.addEventListener('DOMContentLoaded', function () {
        const sections = document.getElementsByTagName('section');
        if (sections.length < 1) {
          return;
        }
        sections.forEach((item) => {
          if (item.childElementCount === 1) {
            item.classList.add('section-center');
            item.classList.add('center');
          } else {
            const option = item.clientHeight / document.body.offsetHeight;
            if (option > 0.75) {
              item.classList.add('section-option');
            }
          }
        });
      });
    </script>
    <script>
      document.addEventListener('DOMContentLoaded', function () {
        // Add lazy loading to all images
        const allImages = document.querySelectorAll('img');
        allImages.forEach((img) => {
          if (!img.hasAttribute('loading')) {
            img.setAttribute('loading', 'lazy');
          }
        });

        // 查找标准的.language-markmap和未被正确解析的markmap代码块
        let markMapList = document.querySelectorAll('.language-markmap');

        // 如果没找到标准格式，查找包含```markmap的代码块
        if (markMapList.length === 0) {
          const codeBlocks = document.querySelectorAll('pre code');
          const additionalMarkMaps = [];
          codeBlocks.forEach(block => {
            const text = block.textContent || '';
            if (text.trim().startsWith('markmap') || text.includes('```markmap')) {
              block.classList.add('language-markmap');
              additionalMarkMaps.push(block);
            }
          });
          markMapList = document.querySelectorAll('.language-markmap');
        }
        markMapList && markMapList.length > 0 &&
          markMapList.forEach((item, i) => {
            const markMapName = 'markmap-' + i;
            const markMapChildClass = '.' + markMapName + ' .markmap';
            let heightAttr = item.textContent.match(
              /\<\!\-\-markmap-height\=(\S*)\-\-\>/,
            );
            // Calculate auto height based on content depth and lines
            const content = item.textContent || '';
            const lines = content.split('\n').filter(line => line.trim());
            const maxDepth = Math.max(0, ...lines.map(line => {
              const match = line.match(/^(\s*)([-*+]|\d+\.)/);
              return match ? Math.floor(match[1].length / 2) : 0;
            }));

            // More reasonable auto height: base 300px + 40px per depth level + 20px per line (slightly larger for PPT)
            // Cap at 500px maximum unless customized
            let autoHeight = Math.min(500, Math.max(300, 300 + maxDepth * 40 + lines.length * 20));
            let height = autoHeight + 'px';

            // Override with manual height if specified
            if (heightAttr && heightAttr.length > 0 && !isNaN(heightAttr[1])) {
              height = heightAttr[1] + 'px';
            }

            item.classList.add('markmap');
            item.classList.add(markMapName);

            // Apply subtle gray background for PPT mode
            const isDark = document.body.classList.contains('dark') ||
                          window.matchMedia('(prefers-color-scheme: dark)').matches;
            const backgroundColor = isDark ? '#1a1f2e' : '#f5f6f7';

            setTimeout(() => {
              const markMapItem = document.querySelector('.' + markMapName);
              markMapItem.style.maxHeight = height;
              markMapItem.style.height = height;
              markMapItem.style.backgroundColor = backgroundColor;
              markMapItem.style.borderRadius = '12px';
              markMapItem.style.overflow = 'hidden';
              setTimeout(() => {
                const markMapItemChild = document.querySelector(markMapChildClass);
                if (markMapItemChild) {
                  markMapItemChild.style.height = height;
                  markMapItemChild.style.backgroundColor = backgroundColor;

                  // Simple PPT markmap fit
                  if (window.markmap && markMapItemChild.markmap) {
                    markMapItemChild.markmap.fit();
                  }
                }
              }, 50);
            }, 10);
          });

      });
    </script>
    <script>
      function postBackgroundColor(currentSlide) {
        let color = '';
        if (
          currentSlide &&
          currentSlide.dataset &&
          currentSlide.dataset.background
        ) {
          color = currentSlide.dataset.background;
        }
        window.webkit &&
          window.webkit.messageHandlers.revealBackgroundColor.postMessage(
            color,
          );
      }

      document.addEventListener('DOMContentLoaded', function () {
        Reveal.on('ready', (event) => {
          postBackgroundColor(event.currentSlide);
        });
        Reveal.on('slidechanged', (event) => {
          postBackgroundColor(event.currentSlide);
        });
      });
    </script>
  </body>
</html>
