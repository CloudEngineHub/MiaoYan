this.markmap = this.markmap || {};
(function (exports) {
  'use strict';

  function _extends() {
    _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key]
          }
        }
      }
      return target
    };
    return _extends.apply(this, arguments)
  }

  Math.random().toString(36).slice(2, 8);

  function memoize(fn) {
    const cache = {};
    return function memoized(...args) {
      const key = `${args[0]}`;
      let data = cache[key];
      if (!data) {
        data = { value: fn(...args) };
        cache[key] = data
      }
      return data.value
    }
  }

  function createElement(tagName, props, attrs) {
    const el = document.createElement(tagName);
    if (props) {
      Object.entries(props).forEach(([key, value]) => {
        el[key] = value
      })
    }
    if (attrs) {
      Object.entries(attrs).forEach(([key, value]) => {
        el.setAttribute(key, value)
      })
    }
    return el
  }

  const memoizedPreloadJS = memoize(url => {
    document.head.append(createElement('link', { rel: 'preload', as: 'script', href: url }))
  });

  function loadJSItem(item, context) {
    if (item.type === 'script') {
      return new Promise((resolve, reject) => {
        var _item$data;
        document.head.append(createElement('script', _extends({}, item.data, { onload: resolve, onerror: reject })));
        if (!((_item$data = item.data) != null && _item$data.src)) resolve()
      })
    }
    if (item.type === 'iife') {
      const { fn, getParams } = item.data;
      fn(...((getParams == null ? void 0 : getParams(context)) || []))
    }
  }

  function loadCSSItem(item) {
    if (item.type === 'style') {
      document.head.append(createElement('style', { textContent: item.data }))
    } else if (item.type === 'stylesheet') {
      document.head.append(createElement('link', _extends({ rel: 'stylesheet' }, item.data)))
    }
  }

  async function loadJS(items, context) {
    const needPreload = items.filter(item => {
      var _item$data2;
      return item.type === 'script' && ((_item$data2 = item.data) == null ? void 0 : _item$data2.src)
    });
    if (needPreload.length > 1) needPreload.forEach(item => memoizedPreloadJS(item.data.src));
    context = _extends({ getMarkmap: () => window.markmap }, context);
    for (const item of items) {
      await loadJSItem(item, context)
    }
  }

  function loadCSS(items) {
    for (const item of items) {
      loadCSSItem(item)
    }
  }

  var _window$markmap, _window$markmap$autoL, _window$markmap2, _window$markmap2$auto;
  const enabled = {};
  const ready = loadJS(((_window$markmap = window.markmap) == null ? void 0 : (_window$markmap$autoL = _window$markmap.autoLoader) == null ? void 0 : _window$markmap$autoL.baseJs) || [{
    type: 'script',
    data: { src: 'js/d3.min.js' }
  }, { type: 'script', data: { src: 'js/markmap-view.min.js' } }]).then(() => {
    var _markmap$autoLoader;
    const { markmap } = window;
    loadCSS([{ type: 'style', data: markmap.globalCSS }]);

    // Add custom styles for cleaner appearance and vibrant colors
    loadCSS([{
      type: 'style',
      data: `
        .markmap-node-circle {
          stroke-width: 1.5px !important;
        }
        .markmap-node text {
          text-shadow: none !important;
          font-weight: 500 !important;
        }
        .markmap svg {
          filter: none !important;
          box-shadow: none !important;
          border: none !important;
          border-radius: 8px !important;
          background: rgba(0, 0, 0, 0.03) !important;
          margin: 0 !important;
          padding: 0 !important;
          box-sizing: border-box !important;
        }
        @media (prefers-color-scheme: dark) {
          .markmap svg {
            background: rgba(255, 255, 255, 0.03) !important;
          }
        }
        .markmap {
          margin: 0 !important;
          padding: 0 !important;
          background: transparent !important;
        }
        .markmap-link {
          stroke-width: 2px !important;
        }
        .markmap-foreign code {
          background-color: transparent !important;
          border-radius: 8px !important;
        }
        .language-markmap {
          background: transparent !important;
        }
        pre.markmap-image-container {
          background: transparent !important;
          padding: 0 !important;
        }
      `
    }]);
    (_markmap$autoLoader = markmap.autoLoader) == null ? void 0 : _markmap$autoLoader.onReady == null ? void 0 : _markmap$autoLoader.onReady()
  });

  function transform(transformer, content) {
    const { root, features } = transformer.transform(content);
    const keys = Object.keys(features).filter(key => !enabled[key]);
    keys.forEach(key => {
      enabled[key] = true
    });
    const { styles, scripts } = transformer.getAssets(keys);
    const { markmap } = window;
    if (styles) markmap.loadCSS(styles);
    if (scripts) markmap.loadJS(scripts);
    return root
  }

  function render(el) {
    const { Transformer, Markmap, autoLoader } = window.markmap;
    const lines = el.textContent.split('\n');
    let indent = Infinity;
    lines.forEach(line => {
      const spaces = line.match(/^\s*/)[0].length;
      if (spaces < line.length) indent = Math.min(indent, spaces)
    });
    const content = lines.map(line => line.slice(indent)).join('\n');
    const transformer = new Transformer(autoLoader == null ? void 0 : autoLoader.transformPlugins);
    el.innerHTML = '<svg></svg>';
    const svg = el.firstChild;

    // Create unique key for each markmap instance
    const contentHash = content.substring(0, 100).replace(/\s+/g, '').slice(0, 50);
    const storageKey = `markmap-zoom-${contentHash}`;
    const savedZoom = localStorage.getItem(storageKey);
    let initialZoom = savedZoom ? JSON.parse(savedZoom) : { scale: 1.2, x: 0, y: 0 };

    const mm = Markmap.create(svg, {
      embedGlobalCSS: true,
      duration: 300,
      autoFit: true,
      paddingX: 16,
      paddingY: 16,
      fitRatio: 0.92,
      spacingVertical: 16,
      zoom: false,
      pan: true,
      color: (d) => {
        // Vibrant color palette
        const colors = [
          '#FF6B6B', // Coral Red
          '#4ECDC4', // Turquoise
          '#45B7D1', // Sky Blue
          '#96CEB4', // Mint Green
          '#FFEAA7', // Warm Yellow
          '#DDA0DD', // Plum
          '#FFA07A', // Light Salmon
          '#20B2AA', // Light Sea Green
          '#87CEEB', // Sky Blue
          '#DEB887', // Burlywood
          '#FF69B4', // Hot Pink
          '#32CD32'  // Lime Green
        ];
        return colors[d.depth % colors.length];
      }
    });

    // Save zoom state on zoom/pan changes with unique key
    let saveTimeout;
    mm.svg.on('zoom', function() {
      clearTimeout(saveTimeout);
      saveTimeout = setTimeout(() => {
        const transform = mm.svg.select('g').attr('transform');
        if (transform) {
          const match = transform.match(/translate\(([^,]+),([^)]+)\)\s*scale\(([^)]+)\)/);
          if (match) {
            const zoomState = {
              x: parseFloat(match[1]),
              y: parseFloat(match[2]),
              scale: parseFloat(match[3]),
              timestamp: Date.now()
            };
            localStorage.setItem(storageKey, JSON.stringify(zoomState));
          }
        }
      }, 300);
    });

    const doRender = () => {
      const root = transform(transformer, content);
      mm.setData(root);

      // Apply saved zoom state after initial render
      setTimeout(() => {
        if (savedZoom && initialZoom) {
          mm.svg.transition().duration(300).call(
            mm.zoom.transform,
            mm.d3.zoomIdentity.translate(initialZoom.x, initialZoom.y).scale(initialZoom.scale)
          );
        } else {
          mm.fit()
        }
      }, 100);
    };
    transformer.hooks.retransform.tap(doRender);
    doRender()
  }

  async function renderAllUnder(container) {
    await ready;
    container.querySelectorAll('.markmap').forEach(render)
  }

  function renderAll() {
    return renderAllUnder(document)
  }

  if (!((_window$markmap2 = window.markmap) != null && (_window$markmap2$auto = _window$markmap2.autoLoader) != null && _window$markmap2$auto.manual)) {
    if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', () => {
      renderAll()
    }); else renderAll()
  }
  exports.ready = ready;
  exports.render = render;
  exports.renderAll = renderAll;
  exports.renderAllUnder = renderAllUnder
})(this.markmap.autoLoader = this.markmap.autoLoader || {});
