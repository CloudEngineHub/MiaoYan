<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="initial-scale=1.0" />
  <meta name="color-scheme" content="light dark" />
  <style>
    img {
      image-rendering: auto;
      color-scheme: only light;
      image-orientation: from-image;
      max-width: 100%;
      height: auto;
    }
  </style>
  DOWN_META
  <link href="css/heti.min.css" rel="stylesheet" />
  <link href="css/katex.min.css" rel="stylesheet" />
  <script src="js/heti-addon.min.js"></script>
  <script src="js/highlight.min.js"></script>
  <script src="js/mermaid.min.js"></script>
  <script src="js/plantuml-encoder.min.js"></script>
  <script src="js/katex.min.js"></script>
  <script src="js/auto-render.min.js"></script>
  <script src="js/emoji.min.js"></script>
  <script src="js/markmap.min.js"></script>
  <script src="js/lightense.min.js"></script>
  <title></title>
  <style>
    @font-face {
      font-family: 'TsangerJinKai02-W04';
      font-display: fallback;
      src: url('DOWN_FONT_PATH/TsangerJinKai02-W04.ttf') format('truetype');
    }

    DOWN_CSS
  </style>
</head>

<body>
  <div class="markdown-body heti" id="write">DOWN_HTML</div>

  <script>
    const heti = new Heti('.heti');
    heti.autoSpacing();
  </script>
  <script>
    hljs.configure({ cssSelector: 'pre code' });
    hljs.highlightAll();
  </script>
  <script>
    const html = document.getElementById('write').innerHTML;
    const emoji = new EmojiConvertor();
    if (/:[^:\s]*(?:::[^:\s]*)*:/.test(html)) {
      document.getElementById('write').innerHTML = emoji.replace_colons(html);
    }
  </script>

  <script>
    function getSelectionAndSendMessage () {
      const txt = document.getSelection().toString();
      window.webkit && window.webkit.messageHandlers.newSelectionDetected.postMessage(txt);
    }

    document.onmouseup = getSelectionAndSendMessage;
    document.onkeyup = getSelectionAndSendMessage;
    document.oncontextmenu = getSelectionAndSendMessage;

    const darkModeStylesNodeID = 'darkModeStyles';

    function addStyleString (str, nodeID) {
      const node = document.createElement('style');
      node.id = nodeID;
      node.innerHTML = str;

      document.getElementsByTagName('head')[0].appendChild(node);
    }

    function switchToDarkMode () {
      const darkModeStyleElement =
        document.getElementById(darkModeStylesNodeID);
      if (darkModeStyleElement == null) {
        const darkModeStyles =
          "* { color: #E7E9EA; } body { background: #21262B; } .heti p > code, .heti li > code, code { background: #454545; } a, .heti a heti-spacing { color: #1D9BF0 } table td, table th { color: #E7E9EA; } input[type='checkbox'] { border: 1px solid white; } .mermaid-image-container, .markmap-image-container, .plantuml-image-container, .plantuml-container { background-color: #282e33; } .plantuml-image { background-color: #282e33; } .hljs{color:#ABB2BF;background:#191F25}.hljs-comment,.hljs-quote{color:#ABB2BF;}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#9B79F7}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#ED716C}.hljs-literal{color:#56b6c2}.hljs-addition,.hljs-attribute,.hljs-meta .hljs-string,.hljs-regexp,.hljs-string{color:#8FFCCD}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#F7CC8F}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#99E0FC}.hljs-built_in,.hljs-class .hljs-title,.hljs-title.class_{color:#ED716C}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}";
        addStyleString(darkModeStyles, darkModeStylesNodeID);

        // Update chart container backgrounds in dark mode
        document.querySelectorAll('.mermaid-image-container, .markmap-image-container, .plantuml-image-container').forEach(container => {
          container.style.backgroundColor = '#282e33';
        });

        // Reinitialize Mermaid with dark theme
        if (window.mermaid) {
          const newConfig = getMermaidConfig();
          window.mermaid.initialize(newConfig);
          const mermaidElements = document.querySelectorAll('.language-mermaid');
          if (mermaidElements.length > 0) {
            mermaidElements.forEach((element, index) => {
              if (!element.dataset.originalContent) {
                element.dataset.originalContent = element.textContent.trim();
              }
              element.removeAttribute('data-processed');
              element.innerHTML = element.dataset.originalContent;
            });
            window.mermaid.init(undefined, mermaidElements);
          }
        }

        // Apply Mermaid dark mode background
        setTimeout(() => {
          document.querySelectorAll('.mermaid, .mermaid svg').forEach(element => {
            element.style.backgroundColor = '#282e33';
          });
          document.querySelectorAll('.mermaid svg rect').forEach(element => {
            if (element.getAttribute('fill') === '#ffffff' || element.getAttribute('fill') === 'white') {
              element.setAttribute('fill', '#282e33');
            }
          });
        }, 100);

        // Apply markmap dark mode background
        const markmapElements = document.querySelectorAll('.markmap');
        markmapElements.forEach(element => {
          element.style.backgroundColor = '#282e33';
          const svgElement = element.querySelector('svg');
          if (svgElement) {
            svgElement.style.backgroundColor = '#282e33';
          }
        });

        // Reset PlantUML processing flags and reprocess
        document.querySelectorAll('.language-plantuml').forEach(el => {
          el.dataset.processed = 'false';
        });
        if (typeof processPlantuml === 'function') {
          processPlantuml();
        }
      }
    }

    function switchToLightMode () {
      const darkModeStyleElement =
        document.getElementById(darkModeStylesNodeID);
      if (darkModeStyleElement != null) {
        darkModeStyleElement.parentElement.removeChild(darkModeStyleElement);
      }

      // Update chart container backgrounds in light mode
      document.querySelectorAll('.mermaid-image-container, .markmap-image-container, .plantuml-image-container').forEach(container => {
        container.style.backgroundColor = '#f7f7f7';
      });

      // Reinitialize Mermaid with light theme
      if (window.mermaid) {
        const newConfig = getMermaidConfig();
        window.mermaid.initialize(newConfig);
        const mermaidElements = document.querySelectorAll('.language-mermaid');
        if (mermaidElements.length > 0) {
          mermaidElements.forEach((element, index) => {
            if (element.dataset.originalContent) {
              element.removeAttribute('data-processed');
              element.innerHTML = element.dataset.originalContent;
            }
          });
          window.mermaid.init(undefined, mermaidElements);
        }
      }

      // Force Mermaid background to match code blocks
      setTimeout(() => {
        document.querySelectorAll('.mermaid, .mermaid svg').forEach(element => {
          element.style.backgroundColor = '#f7f7f7';
        });
        document.querySelectorAll('.mermaid svg rect').forEach(element => {
          if (element.getAttribute('fill') === '#282e33' || element.getAttribute('fill') === '#21262B') {
            element.setAttribute('fill', '#f7f7f7');
          }
        });
      }, 100);

      // Restore markmap light mode styles
      const markmapElements = document.querySelectorAll('.markmap');
      markmapElements.forEach(element => {
        element.style.backgroundColor = '#f7f7f7';
        const svgElement = element.querySelector('svg');
        if (svgElement) {
          svgElement.style.backgroundColor = '#f7f7f7';
        }
      });

      // Reset PlantUML processing flags and reprocess
      document.querySelectorAll('.language-plantuml').forEach(el => {
        el.dataset.processed = 'false';
      });
      if (typeof processPlantuml === 'function') {
        processPlantuml();
      }
    }

    if ('CUSTOM_CSS' === 'darkmode') {
      switchToDarkMode();
    }
  </script>

  <script>
    const inputList = document.getElementsByTagName('input');

    for (let i = 0; i < inputList.length; i++) {
      inputList[i].disabled = true;

      if (
        inputList[i].parentNode.tagName === 'P' &&
        inputList[i].parentNode.parentNode.tagName === 'LI'
      ) {
        inputList[i].parentNode.parentNode.parentNode.classList.add('cb');
        continue;
      }

      if (inputList[i].parentNode.tagName !== 'LI') {
        continue;
      }

      inputList[i].parentNode.parentNode.classList.add('cb');
    }
  </script>

  <script>
    const addCheckboxEvent = function (element) {
      if (element.parentNode.nodeName === 'LI') {
        element.parentNode.classList.remove('strike');
      }

      let id = element.dataset.checkbox;
      window.webkit && window.webkit.messageHandlers.checkbox.postMessage(id);

      let input = document.createElement('input');
      input.type = 'checkbox';
      input.dataset.checkbox = id;

      if (!element.hasAttribute('checked')) {
        input.defaultChecked = true;

        if (element.parentNode.nodeName === 'LI') {
          element.parentNode.classList.add('strike');
        }
      }

      element.parentNode.replaceChild(input, element);

      input.addEventListener('click', function (event) {
        addCheckboxEvent(input);
      });
    };

    const checkboxList = document.querySelectorAll('input[type=checkbox]');

    for (let i = 0; i < checkboxList.length; i++) {
      if (
        checkboxList[i].parentNode.nodeName === 'LI' &&
        checkboxList[i].hasAttribute('checked')
      ) {
        checkboxList[i].parentNode.classList.add('strike');
      }

      checkboxList[i].disabled = false;
      checkboxList[i].dataset.checkbox = i;

      checkboxList[i].addEventListener('click', function (event) {
        let element = event.target;
        addCheckboxEvent(element);
      });
    }
  </script>

  <script>
    // Check if dark mode is active
    function isDarkMode() {
      return 'CUSTOM_CSS' === 'darkmode' || document.getElementById('darkModeStyles') !== null;
    }

    // Enhanced Mermaid theme configuration with unified color scheme
    function getMermaidConfig() {
      const darkTheme = {
        background: '#282e33',
        primaryColor: '#3a4045',
        primaryBorderColor: '#6b7280',
        primaryTextColor: '#E7E9EA',
        secondaryColor: '#454545',
        tertiaryColor: '#3a4045',
        lineColor: '#6b7280',
        textColor: '#E7E9EA',
        mainBkg: '#3a4045',
        secondBkg: '#454545',
        tertiaryTextColor: '#E7E9EA',
        nodeBorder: '#6b7280',
        clusterBkg: '#3a4045',
        clusterBorder: '#6b7280',
        edgeLabelBackground: '#282e33',
        actorBkg: '#3a4045',
        actorBorder: '#6b7280',
        actorTextColor: '#E7E9EA',
        actorLineColor: '#6b7280',
        signalColor: '#E7E9EA',
        signalTextColor: '#E7E9EA',
        labelBoxBkgColor: '#3a4045',
        labelBoxBorderColor: '#6b7280',
        labelTextColor: '#E7E9EA',
        loopTextColor: '#E7E9EA',
        noteTextColor: '#E7E9EA',
        noteBkgColor: '#3a4045',
        noteBorderColor: '#6b7280',
        // 添加更多线条相关的颜色配置
        arrowheadColor: '#6b7280',
        edgeColor: '#6b7280',
        relationColor: '#6b7280'
      };

      const lightTheme = {
        background: '#f7f7f7',
        primaryColor: '#ffffff',
        primaryBorderColor: '#d0d0d0',
        primaryTextColor: '#333333',
        secondaryColor: '#efefef',
        tertiaryColor: '#f0f0f0',
        lineColor: '#d0d0d0',
        textColor: '#333333',
        mainBkg: '#ffffff',
        secondBkg: '#efefef',
        tertiaryTextColor: '#333333',
        nodeBorder: '#d0d0d0',
        clusterBkg: '#ffffff',
        clusterBorder: '#d0d0d0',
        edgeLabelBackground: '#f7f7f7',
        actorBkg: '#ffffff',
        actorBorder: '#d0d0d0',
        actorTextColor: '#333333',
        actorLineColor: '#d0d0d0',
        signalColor: '#333333',
        signalTextColor: '#333333',
        labelBoxBkgColor: '#ffffff',
        labelBoxBorderColor: '#d0d0d0',
        labelTextColor: '#333333',
        loopTextColor: '#333333',
        noteTextColor: '#333333',
        noteBkgColor: '#ffffff',
        noteBorderColor: '#d0d0d0'
      };

      const baseConfig = {
        startOnLoad: true,
        theme: isDarkMode() ? 'dark' : 'base',
        fontFamily: 'Helvetica, Arial, sans-serif',
        flowchart: {
          useMaxWidth: false,
          htmlLabels: true,
        },
        themeVariables: isDarkMode() ? darkTheme : lightTheme
      };

      return baseConfig;
    }

    const config = getMermaidConfig();
    mermaid.initialize(config);
    window.mermaid.init(
      undefined,
      document.querySelectorAll('.language-mermaid')
    );

    // PlantUML processing with comprehensive theme support
    function getPlantUMLSkinparams() {
      if (isDarkMode()) {
        return `skinparam backgroundColor #282e33
skinparam defaultTextColor #E7E9EA
skinparam defaultFontColor #E7E9EA
skinparam defaultFontName "Helvetica"
skinparam defaultFontSize 12
skinparam actorBorderColor #6b7280
skinparam actorBackgroundColor #3a4045
skinparam actorFontColor #E7E9EA
skinparam participantBorderColor #6b7280
skinparam participantBackgroundColor #3a4045
skinparam participantFontColor #E7E9EA
skinparam classBorderColor #6b7280
skinparam classBackgroundColor #3a4045
skinparam classFontColor #E7E9EA
skinparam classAttributeFontColor #E7E9EA
skinparam sequenceLifeLineBorderColor #6b7280
skinparam sequenceActorBorderColor #6b7280
skinparam sequenceActorBackgroundColor #3a4045
skinparam sequenceActorFontColor #E7E9EA
skinparam sequenceGroupBorderColor #6b7280
skinparam sequenceGroupBackgroundColor #3a4045
skinparam sequenceGroupHeaderFontColor #E7E9EA
skinparam sequenceMessageTextAlignment center
skinparam arrowColor #6b7280
skinparam sequenceArrowColor #6b7280
skinparam usecaseArrowColor #6b7280
skinparam classArrowColor #6b7280
skinparam componentArrowColor #6b7280
skinparam stateArrowColor #6b7280
skinparam activityArrowColor #6b7280
skinparam note {
  BackgroundColor #3a4045
  BorderColor #6b7280
  FontColor #E7E9EA
}
skinparam activity {
  BackgroundColor #3a4045
  BorderColor #6b7280
  FontColor #E7E9EA
  ArrowColor #6b7280
}
skinparam state {
  BackgroundColor #3a4045
  BorderColor #6b7280
  FontColor #E7E9EA
  ArrowColor #6b7280
}
skinparam usecase {
  BackgroundColor #3a4045
  BorderColor #6b7280
  FontColor #E7E9EA
  ArrowColor #6b7280
}
skinparam component {
  BackgroundColor #3a4045
  BorderColor #6b7280
  FontColor #E7E9EA
  ArrowColor #6b7280
}`;
      } else {
        return `skinparam backgroundColor #f7f7f7
skinparam defaultTextColor #333333
skinparam defaultFontColor #333333
skinparam defaultFontName "Helvetica"
skinparam defaultFontSize 12
skinparam actorBorderColor #d0d0d0
skinparam actorBackgroundColor #ffffff
skinparam actorFontColor #333333
skinparam participantBorderColor #d0d0d0
skinparam participantBackgroundColor #ffffff
skinparam participantFontColor #333333
skinparam classBorderColor #d0d0d0
skinparam classBackgroundColor #ffffff
skinparam classFontColor #333333
skinparam classAttributeFontColor #333333
skinparam sequenceLifeLineBorderColor #d0d0d0
skinparam sequenceActorBorderColor #d0d0d0
skinparam sequenceActorBackgroundColor #ffffff
skinparam sequenceActorFontColor #333333
skinparam sequenceGroupBorderColor #d0d0d0
skinparam sequenceGroupBackgroundColor #ffffff
skinparam sequenceGroupHeaderFontColor #333333
skinparam sequenceMessageTextAlignment center
skinparam note {
  BackgroundColor #ffffff
  BorderColor #d0d0d0
  FontColor #333333
}
skinparam activity {
  BackgroundColor #ffffff
  BorderColor #d0d0d0
  FontColor #333333
}
skinparam state {
  BackgroundColor #ffffff
  BorderColor #d0d0d0
  FontColor #333333
}`;
      }
    }

    function processPlantuml() {
      if (typeof plantumlEncoder === 'undefined') {
        console.warn('PlantUML encoder not loaded, retrying...');
        setTimeout(processPlantuml, 500);
        return;
      }

      let plantumlPrefix = 'language-plantuml';
      const plantumlElements = document.querySelectorAll('[class^=' + plantumlPrefix + ']');

      if (plantumlElements.length === 0) return;

      Array.prototype.forEach.call(plantumlElements, function (code) {
        // Skip if already processed
        if (code.dataset.processed === 'true') {
          return;
        }

        // Remove existing image if already processed
        const existingImage = code.parentNode.querySelector('.plantuml-image');
        if (existingImage) {
          existingImage.remove();
        }

        let image = document.createElement('img');
        image.className = 'plantuml-image';
        image.loading = 'lazy';

        // Apply comprehensive theme configuration
        let plantumlContent = code.innerText;
        const skinparams = getPlantUMLSkinparams();

        // Remove existing skinparam lines to avoid conflicts
        plantumlContent = plantumlContent.replace(/skinparam\s+[^\n]*/g, '');

        // Add comprehensive skinparam configuration
        plantumlContent = skinparams + '\n' + plantumlContent;

        // Enhanced styling for container - unified with other diagrams
        setTimeout(() => {
          image.style.borderRadius = '6px';
          image.style.display = 'block';
          image.style.margin = '0 auto'; // Center the image
          image.style.textAlign = 'center';

          if (image.parentNode) {
            image.parentNode.style.backgroundColor = isDarkMode() ? '#282e33' : '#f7f7f7';
            image.parentNode.style.padding = '12px';
            image.parentNode.style.borderRadius = '6px';
            image.parentNode.style.border = 'none';
            image.parentNode.style.boxShadow = 'none';
            image.parentNode.style.textAlign = 'center'; // Center container content
            image.parentNode.classList.add('plantuml-container');
          }
        }, 100);

        image.src = 'http://www.plantuml.com/plantuml/svg/~1' + plantumlEncoder.encode(plantumlContent);

        // Add error handling for image loading
        image.onerror = function() {
          console.warn('PlantUML image failed to load, showing code block instead');
          code.style.display = 'block';
          image.style.display = 'none';
        };

        image.onload = function() {
          code.style.display = 'none';
          image.style.display = 'block';
          // Set image background to match theme
          image.style.backgroundColor = isDarkMode() ? '#282e33' : '#f7f7f7';
          // Center and size the image properly
          image.style.maxWidth = '100%';
          image.style.width = 'auto';
          image.style.height = 'auto';
          image.style.margin = '0 auto';
          image.style.display = 'block'; // Ensure block display for centering

          // Container uses default font for consistency
        };

        code.parentNode.insertBefore(image, code);
        code.style.display = 'none';

        // Store original content for theme switching
        if (!code.dataset.originalContent) {
          code.dataset.originalContent = code.innerText;
        }

        // Mark as processed
        code.dataset.processed = 'true';
      });
    }

    // Initialize PlantUML
    processPlantuml();

    const preList = document.getElementsByTagName('pre');

    for (let i = 0; i < preList.length; i++) {
      if (preList[i].querySelector('.plantuml-image')) {
        preList[i].classList.add('plantuml-image-container');
      }
      if (preList[i].querySelector('.language-mermaid')) {
        preList[i].classList.add('mermaid-image-container');
      }
      if (preList[i].querySelector('.language-markmap')) {
        preList[i].classList.add('markmap-image-container');
      }
    }
  </script>
  <script>
    document.addEventListener('DOMContentLoaded', function () {
      renderMathInElement(document.body, {
        delimiters: [
          { left: '$$', right: '$$', display: true },
          { left: '$', right: '$', display: false },
          { left: '\\(', right: '\\)', display: false },
          { left: '\\[', right: '\\]', display: true },
        ],
        throwOnError: false,
      });
    });
  </script>
  <script>
    document
      .querySelectorAll('h1, h2, h3, h4, h5, h6,h7')
      .forEach((h) => (h.id = h.innerText));
    document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
      anchor.addEventListener('click', function (e) {
        e.preventDefault();
        document
          .querySelector(decodeURIComponent(this.getAttribute('href')))
          .scrollIntoView({
            behavior: 'smooth',
          });
      });
    });
  </script>
  <script>
    // Enhanced markmap initialization with unified theme
    function getMarkmapColorOptions() {
      if (isDarkMode()) {
        return {
          colorFreezeLevel: 6,
          color: ['#E7E9EA', '#99E0FC', '#F7CC8F', '#8FFCCD', '#ED716C', '#9B79F7', '#56b6c2'],
          backgroundColor: '#282e33',
          nodeBackgroundColor: '#3a4045',
          nodeBorderColor: '#454545',
          linkColor: '#454545'
        };
      } else {
        return {
          colorFreezeLevel: 6,
          color: ['#333333', '#0066cc', '#cc6600', '#00aa00', '#cc0000', '#6600cc', '#006666'],
          backgroundColor: '#f7f7f7',
          nodeBackgroundColor: '#ffffff',
          nodeBorderColor: '#d0d0d0',
          linkColor: '#d0d0d0'
        };
      }
    }

    document.addEventListener('DOMContentLoaded', function () {
      if (!window.markmap) return;

      // Find markmap elements with simple selector
      const markMapElements = document.querySelectorAll('.language-markmap');

      markMapElements.forEach((element, index) => {
        element.classList.add('markmap');
        const colorOptions = getMarkmapColorOptions();

        // Apply unified styling
        element.style.backgroundColor = colorOptions.backgroundColor;
        element.style.borderRadius = '6px';
        element.style.padding = '12px';
        element.style.overflow = 'hidden'; // Prevent zoom/pan overflow and scrolling
        element.style.textAlign = 'center'; // Center alignment like other diagrams
        element.style.minHeight = '300px'; // Consistent minimum height
        element.style.pointerEvents = 'none'; // Disable all mouse interactions

        // Store theme options for potential markmap integration
        element.dataset.markmapColors = JSON.stringify(colorOptions);
      });

      // Optimize image loading: first 3 images load immediately, others lazy load
      const allImages = document.querySelectorAll('img');
      allImages.forEach((img, index) => {
        img.setAttribute('loading', index < 3 ? 'eager' : 'lazy');
        img.style.maxWidth = '100%';
        img.style.height = 'auto';
      });

      // Image zoom with theme-aware background
      const zoomImgs = document.querySelectorAll('#write>img, #write>p>img,#write>table img');
      if (zoomImgs.length > 0) {
        Lightense &&
          Lightense(zoomImgs, {
            background: isDarkMode() ? 'rgba(33, 38, 43, .8)' : 'rgba(255, 255, 255, .8)',
          });
      }

    });
  </script>
</body>

</html>
